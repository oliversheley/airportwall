<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KFOE Field Conditions & Weather</title>

  <style>
    :root{
      --bg:#0b0f14;
      --card:#111823;
      --text:#e8eef6;
      --muted:#9fb0c3;
      --accent:#57a6ff;

      --vfr:#2bdc4f;
      --mvfr:#4aa3ff;
      --ifr:#ff4d4d;     /* RED */
      --lifr:#c84dff;    /* MAGENTA */
      --unk:#6f7d8f;

      --age:#ff9a3d;
      --divider:rgba(255,255,255,0.08);
    }

    *{ box-sizing:border-box; }
    html, body{ height:100%; overflow:hidden; }
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background:var(--bg);
      color:var(--text);
    }

    .wrap{
      height:100vh;
      display:grid;
      grid-template-rows:auto 1fr;
      gap:12px;
      padding:16px;
      min-height:0;
    }

    header{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:16px;
    }

    .title{
      font-size:clamp(22px, 1.8vw, 30px);
      font-weight:800;
      letter-spacing:0.2px;
    }
    .subtitle{
      color:var(--muted);
      font-size:clamp(12px, 0.9vw, 14px);
      margin-top:2px;
    }

    /* ===== Layout: left 1/3 (metar+taf), right 2/3 (windy) ===== */
    .main{
      height:100%;
      min-height:0;
      display:grid;
      grid-template-columns: 1fr 2fr; /* 1/3 : 2/3 */
      gap:12px;
    }

    .left{
      min-height:0;
      display:grid;
      grid-template-rows: 1fr 1fr;   /* METAR top, TAF bottom */
      gap:12px;
    }

    .card{
      background:var(--card);
      border:1px solid rgba(255,255,255,0.06);
      border-radius:16px;
      padding:14px;
      overflow:hidden;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
      min-height:0;
      display:flex;
      flex-direction:column;
    }

    .card h2{
      margin:0 0 10px 0;
      font-size:clamp(14px, 1vw, 16px);
      color:var(--muted);
      font-weight:700;
      letter-spacing:0.3px;
      flex:0 0 auto;
    }

    iframe{
      width:100%;
      flex:1;
      min-height:0;
      border:0;
      border-radius:12px;
      background:#000;
    }

    .small{ color:var(--muted); font-size:12px; }
    .accent{ color:var(--accent); font-weight:800; }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }

    .cat-vfr{ color:var(--vfr); }
    .cat-mvfr{ color:var(--mvfr); }
    .cat-ifr{ color:var(--ifr); }
    .cat-lifr{ color:var(--lifr); }
    .cat-unk{ color:#d7e3f3; }
    .error{ color:#ff6b6b; font-weight:800; }

    /* NEW: hazard highlight (RED) */
    .haz-red{
      color: var(--ifr);
      font-weight: 1000;
    }

    /* ===== METAR ===== */
    .metarTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:10px 12px;
      border-radius:14px;
      background:rgba(255,255,255,0.03);
      border:1px solid rgba(255,255,255,0.06);
      margin-bottom:10px;
      flex:0 0 auto;
    }
    .catBadge{
      display:flex;
      align-items:center;
      gap:10px;
      font-weight:900;
      font-size:clamp(18px, 1.55vw, 24px);
      letter-spacing:0.4px;
    }
    .dot{
      width:22px;
      height:22px;
      border-radius:999px;
      box-shadow: 0 0 0 3px rgba(255,255,255,0.06) inset;
    }
    .ageBadge{
      font-weight:900;
      font-size:clamp(16px, 1.35vw, 22px);
      color:var(--age);
      white-space:nowrap;
    }

    .metarRaw{
      font-size:clamp(12px, 0.95vw, 15px);
      font-weight:900;
      padding:10px 12px;
      border-radius:14px;
      background:rgba(255,255,255,0.02);
      border:1px solid rgba(255,255,255,0.06);
      margin-bottom:10px;
      line-height:1.25;
      white-space:pre-wrap;
      word-break:break-word;
      flex:0 0 auto;
    }

    .kvTable{
      border-radius:16px;
      background:rgba(255,255,255,0.02);
      border:1px solid rgba(255,255,255,0.06);
      overflow:hidden;
      flex:1 1 auto;
      min-height:0;
      display:flex;
      flex-direction:column;
    }

    .kvRow{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      padding:clamp(6px, 0.7vh, 10px) 12px;
      border-top:1px solid var(--divider);
      align-items:center;
      flex: 1 0 auto;
      min-height:0;
    }
    .kvRow:first-child{ border-top:none; }

    .kvLabel{
      color:rgba(255,255,255,0.92);
      font-size:clamp(12px, 0.9vw, 15px);
      font-weight:800;
      text-align:center;
      line-height:1.1;
    }
    .kvValue{
      color:var(--mvfr);
      font-size:clamp(12px, 0.95vw, 16px);
      font-weight:900;
      text-align:center;
      letter-spacing:0.2px;
      line-height:1.1;
      white-space:nowrap;
    }

    .obsLine{
      margin-top:8px;
      flex:0 0 auto;
      font-size:12px;
      color:var(--muted);
    }

    /* ===== TAF ===== */
    .tafHeader{ flex:0 0 auto; }

    .tafBlock{
      flex:1 1 auto;
      min-height:0;
      white-space:pre-wrap;
      word-break:break-word;
      font-size:clamp(12px, 0.95vw, 14px);
      line-height:1.35;
      overflow:hidden;

      -webkit-mask-image: linear-gradient(to bottom, #000 88%, transparent);
      mask-image: linear-gradient(to bottom, #000 88%, transparent);
    }
    .tafLine{ display:block; }

    /* ===== TAF timeline bar ===== */
    .tafBarWrap{
      flex:0 0 auto;
      margin-top:10px;
    }
    .tafBarLabel{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      font-size:12px;
      color:var(--muted);
      margin-bottom:6px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .tafBar{
      position:relative;
      height:12px;
      border-radius:999px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,0.10);
      background:rgba(255,255,255,0.04);
      display:flex;
    }
    .tafSeg{
      height:100%;
      flex:1 1 auto;
      border-right:1px solid rgba(0,0,0,0.35);
      min-width:2px;
    }
    .tafSeg:last-child{ border-right:none; }

    .seg-vfr{ background:var(--vfr); }
    .seg-mvfr{ background:var(--mvfr); }
    .seg-ifr{ background:var(--ifr); }
    .seg-lifr{ background:var(--lifr); }
    .seg-unk{ background:var(--unk); }

    /* subtle hour ticks (every 6 hours) */
    .tafBar::after{
      content:"";
      position:absolute;
      inset:0;
      pointer-events:none;
      background:
        linear-gradient(to right,
          transparent 0,
          transparent calc(100%/4 - 1px),
          rgba(0,0,0,0.35) calc(100%/4 - 1px),
          rgba(0,0,0,0.35) calc(100%/4)
        );
      background-size: calc(100%/4) 100%;
      opacity:0.55;
      mix-blend-mode: multiply;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div>
        <div class="title">KFOE — Forbes Field</div>
        <div class="subtitle">METAR/TAF + Radar (Windy) • Auto-refresh</div>
      </div>
      <div class="subtitle" id="clock"></div>
    </header>

    <div class="main">
      <!-- LEFT 1/3: METAR + TAF -->
      <div class="left">
        <!-- METAR -->
        <div class="card">
          <h2>METAR</h2>

          <div class="metarTop">
            <div class="catBadge">
              <span id="catDot" class="dot" style="background: var(--unk);"></span>
              <span id="catText" class="cat-unk">—</span>
            </div>
            <div id="ageBadge" class="ageBadge">—</div>
          </div>

          <div id="metarraw" class="metarRaw mono cat-unk">Loading…</div>

          <div class="kvTable">
            <div class="kvRow">
              <div class="kvLabel">Time</div>
              <div class="kvValue" id="m_time">—</div>
            </div>
            <div class="kvRow">
              <div class="kvLabel">Wind</div>
              <div class="kvValue" id="m_wind">—</div>
            </div>
            <div class="kvRow">
              <div class="kvLabel">Visibility</div>
              <div class="kvValue" id="m_vis">—</div>
            </div>
            <div class="kvRow">
              <div class="kvLabel">Clouds (AGL)</div>
              <div class="kvValue" id="m_clouds">—</div>
            </div>
            <div class="kvRow">
              <div class="kvLabel">Temperature</div>
              <div class="kvValue" id="m_temp">—</div>
            </div>
            <div class="kvRow">
              <div class="kvLabel">Dewpoint</div>
              <div class="kvValue" id="m_dew">—</div>
            </div>
            <div class="kvRow">
              <div class="kvLabel">Altimeter</div>
              <div class="kvValue" id="m_alt">—</div>
            </div>
          </div>

          <div class="obsLine">Obs time: <span class="accent" id="obstime">—</span></div>
        </div>

        <!-- TAF -->
        <div class="card">
          <div class="tafHeader">
            <h2>TAF (Raw with Line Breaks + Colors)</h2>
            <div class="small" id="tafmeta">Loading…</div>
          </div>

          <div id="tafBlock" class="tafBlock mono cat-unk">Loading…</div>

          <!-- NEW: 24h category timeline bar -->
          <div class="tafBarWrap">
            <div class="tafBarLabel" id="tafBarLabel">Next 24h: —</div>
            <div class="tafBar" id="tafBar" aria-label="TAF 24 hour flight category bar"></div>
          </div>
        </div>
      </div>

      <!-- RIGHT 2/3: WINDY -->
      <div class="card">
        <h2>Radar / Weather Map (Windy embed)</h2>
        <iframe id="windyRadar" loading="lazy" referrerpolicy="no-referrer"></iframe>
      </div>
    </div>
  </div>

  <script>
    "use strict";

    // ====== CONFIG ======
    const STATION = "KFOE";
    const PROXY_BASE = "https://kfoe-awc-proxy.oliversheley.workers.dev";

    const LAT = 38.95083;
    const LON = -95.66361;

    const WINDY_RADAR_URL =
      "https://embed.windy.com/embed2.html" +
      `?lat=${encodeURIComponent(LAT)}` +
      `&lon=${encodeURIComponent(LON)}` +
      `&detailLat=${encodeURIComponent(LAT)}` +
      `&detailLon=${encodeURIComponent(LON)}` +
      "&width=100%&height=100%" +
      "&zoom=9&level=surface" +
      "&overlay=rain" +
      "&product=ecmwf" +
      "&menu=&message=true&marker=true" +
      "&calendar=now&pressure=true" +
      "&type=map&location=coordinates&detail=true" +
      "&metricWind=default&metricTemp=default&radarRange=-1";

    // ====== STATE ======
    let lastObsMs = null;

    // ====== HELPERS ======
    const $ = (id) => document.getElementById(id);

    function setClock(){ $("clock").textContent = new Date().toLocaleString(); }
    function safe(v, fallback="—"){ return (v === undefined || v === null || v === "") ? fallback : v; }

    function catClass(cat){
      switch (String(cat || "").toUpperCase()){
        case "VFR":  return "cat-vfr";
        case "MVFR": return "cat-mvfr";
        case "IFR":  return "cat-ifr";
        case "LIFR": return "cat-lifr";
        default:     return "cat-unk";
      }
    }
    function catColorVar(cat){
      switch (String(cat || "").toUpperCase()){
        case "VFR":  return "var(--vfr)";
        case "MVFR": return "var(--mvfr)";
        case "IFR":  return "var(--ifr)";
        case "LIFR": return "var(--lifr)";
        default:     return "var(--unk)";
      }
    }

    function parseTimeToMs(t){
      if (t == null) return null;
      if (typeof t === "number" && Number.isFinite(t)){
        if (t > 1e12) return t;
        if (t > 1e9)  return t * 1000;
        return null;
      }
      if (typeof t === "string"){
        const s = t.trim();
        if (/^\d{9,16}$/.test(s)){
          const n = Number(s);
          if (!Number.isFinite(n)) return null;
          if (n > 1e12) return n;
          if (n > 1e9)  return n * 1000;
        }
        const ms = Date.parse(s);
        return Number.isFinite(ms) ? ms : null;
      }
      return null;
    }

    function computeAgeMinutesFromMs(ms){
      if (!Number.isFinite(ms)) return null;
      const diff = Date.now() - ms;
      if (!Number.isFinite(diff) || diff < 0) return null;
      const mins = Math.round(diff / 60000);
      if (mins > 24 * 60 * 7) return null;
      return mins;
    }

    function refreshAgeOnly(){
      const mins = computeAgeMinutesFromMs(lastObsMs);
      $("ageBadge").textContent = (mins == null) ? "—" : `${mins}m ago`;
    }

    function formatLocalTimeWithTZFromMs(ms){
      if (!Number.isFinite(ms)) return "—";
      return new Date(ms).toLocaleTimeString([], { hour:"2-digit", minute:"2-digit", timeZoneName:"short" });
    }

    function formatObsLineFromMs(ms){
      if (!Number.isFinite(ms)) return "—";
      return new Date(ms).toLocaleString([], { month:"2-digit", day:"2-digit", hour:"2-digit", minute:"2-digit", timeZoneName:"short" });
    }

    function cloudPhrase(clouds){
      if (!Array.isArray(clouds) || !clouds.length) return "Clear";
      const sorted = clouds.filter(c=>Number.isFinite(c.base)).sort((a,b)=>a.base-b.base);
      if (!sorted.length) return "—";
      const pick = sorted.find(c => ["OVC","BKN","VV"].includes(String(c.cover||"").toUpperCase())) || sorted[0];
      const cover = String(pick.cover||"").toUpperCase();
      const base = pick.base;
      const coverWord = ({OVC:"Overcast",BKN:"Broken",SCT:"Scattered",FEW:"Few",VV:"Vertical Vis"})[cover] || cover;
      return `${coverWord} ${base.toLocaleString()}′`;
    }

    function cToF(c){ return Number.isFinite(c) ? (c * 9/5) + 32 : null; }

    function parseAltimeterInHg(alt){
      if (alt == null) return null;
      const n = Number(alt);
      if (!Number.isFinite(n)) return null;
      if (n >= 20 && n <= 35) return n;
      if (n >= 2000 && n <= 3500) return n / 100;
      if (n >= 800 && n <= 1100) return n * 0.029529983;
      return null;
    }

    async function fetchJSON(path){
      const url = `${PROXY_BASE}${path}`;
      const res = await fetch(url, { cache:"no-store" });
      if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
      return res.json();
    }

    /* ====== METAR hazard highlighting ====== */
    function escapeHTML(s){
      return String(s)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#39;");
    }
    function escapeRegExp(s){
      return String(s).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    function visTokenFromRaw(raw){
      // tokens: M1/4SM, 1/4SM, 1/8SM, 0SM, 1 1/4SM, P6SM, 2SM, etc
      const m = String(raw || "").match(/\b(M?\d+\s+\d\/\d|M?\d+\/\d+|M?\d+(?:\.\d+)?|P6)\s?SM\b/);
      return m ? m[0] : null;
    }

    function parseVisTokenToNumber(token){
      if (!token) return null;
      let t = token.toUpperCase().replace("SM", "").trim();

      if (t === "P6") return 10;

      let lessThan = false;
      if (t.startsWith("M")){
        lessThan = true;
        t = t.slice(1);
      }

      const parts = t.split(/\s+/).filter(Boolean);

      function fracToFloat(f){
        const [a,b] = f.split("/").map(Number);
        if (!Number.isFinite(a) || !Number.isFinite(b) || b === 0) return null;
        return a / b;
      }

      let val = null;
      if (parts.length === 2 && parts[1].includes("/")){
        const whole = Number(parts[0]);
        const frac = fracToFloat(parts[1]);
        if (Number.isFinite(whole) && frac != null) val = whole + frac;
      } else if (parts.length === 1 && parts[0].includes("/")){
        val = fracToFloat(parts[0]);
      } else if (parts.length === 1){
        const n = Number(parts[0]);
        if (Number.isFinite(n)) val = n;
      }

      if (!Number.isFinite(val)) return null;
      if (lessThan) val = Math.max(0, val - 0.01); // M1/4 => slightly below 0.25
      return val;
    }

    function parseVisGeneric(visib){
      if (visib == null) return null;
      if (typeof visib === "number" && Number.isFinite(visib)) return visib;

      const s = String(visib).trim().toUpperCase();
      if (!s) return null;
      if (s === "6+" || s === "6+") return 10;
      if (s === "P6" || s === "P6SM") return 10;
      if (s.includes("SM")) return parseVisTokenToNumber(s);
      return parseVisTokenToNumber(s + "SM");
    }

    function detectMetarHazards(raw, visib){
      const r = String(raw || "").toUpperCase();
      const hasFzra = r.includes("FZRA");
      const hasFzfg = r.includes("FZFG");

      const vFromField = parseVisGeneric(visib);
      const token = visTokenFromRaw(raw);
      const vFromRaw = parseVisTokenToNumber(token);

      const vis = (vFromField != null) ? vFromField : vFromRaw;
      const visLow = (vis != null && vis <= 0.25);

      return { hasFzra, hasFzfg, visLow, visToken: token };
    }

    function formatMetarRawHTML(raw, hazards){
      let s = escapeHTML(raw);

      // highlight freezing rain/fog tokens
      s = s.replace(/FZRA/g, '<span class="haz-red">FZRA</span>');
      s = s.replace(/FZFG/g, '<span class="haz-red">FZFG</span>');

      // highlight the visibility token if it’s <= 0.25 and we can find the exact token
      if (hazards.visLow && hazards.visToken){
        const escTok = escapeHTML(hazards.visToken);
        const re = new RegExp("\\b" + escapeRegExp(escTok) + "\\b", "g");
        s = s.replace(re, `<span class="haz-red">${escTok}</span>`);
      }
      return s;
    }

    function setKv(id, text, hazardRed=false){
      const el = $(id);
      el.textContent = text;
      el.className = "kvValue" + (hazardRed ? " haz-red" : "");
    }

    /* ===== TAF helpers ===== */
    function tafRawToLines(rawTAF){
      const s = String(rawTAF || "").trim();
      if (!s) return [];
      const normalized = s
        .replace(/^TAF\s+/i, "TAF ")
        .replace(/\s+(FM\d{6})/g, "\n$1")
        .replace(/\s+(TEMPO)/g, "\n$1")
        .replace(/\s+(BECMG)/g, "\n$1")
        .replace(/\s+(PROB\d{2})/g, "\n$1");
      return normalized.split("\n").map(x=>x.trim()).filter(Boolean);
    }

    function ceilingFeetFromClouds(clouds){
      if (!Array.isArray(clouds) || !clouds.length) return null;
      const candidates = clouds
        .filter(c => ["BKN","OVC","VV"].includes(String(c.cover||"").toUpperCase()) && Number.isFinite(c.base))
        .sort((a,b)=>a.base-b.base);
      return candidates.length ? candidates[0].base : null;
    }

    function visToNumber(vis){
      if (vis == null) return null;
      if (typeof vis === "number") return Number.isFinite(vis) ? vis : null;
      if (typeof vis === "string"){
        const s = vis.trim().replace("+","");
        const n = Number(s);
        return Number.isFinite(n) ? n : null;
      }
      return null;
    }

    function flightCategoryFrom(visSM, ceilFT){
      function visCat(v){
        if (v == null) return null;
        if (v < 1) return "LIFR";
        if (v < 3) return "IFR";
        if (v <= 5) return "MVFR";
        return "VFR";
      }
      function ceilCat(c){
        if (c == null) return null;
        if (c < 500) return "LIFR";
        if (c < 1000) return "IFR";
        if (c < 3000) return "MVFR";
        return "VFR";
      }
      const a = visCat(visSM);
      const b = ceilCat(ceilFT);
      if (a && b){
        const rank={LIFR:0, IFR:1, MVFR:2, VFR:3};
        return (rank[a] < rank[b]) ? a : b;
      }
      return a || b || "UNK";
    }

    function fmtUnixLocal(unixSec){
      if (!unixSec || !Number.isFinite(unixSec)) return "—";
      const d = new Date(unixSec * 1000);
      return d.toLocaleString([], { month:"2-digit", day:"2-digit", hour:"2-digit", minute:"2-digit" });
    }

    /* ===== NEW: Build 24h bar from fcsts (worst-of-overlap, includes TEMPO) ===== */
    function catRank(cat){
      const c = String(cat || "UNK").toUpperCase();
      const rank = { "LIFR":0, "IFR":1, "MVFR":2, "VFR":3, "UNK":4 };
      return (c in rank) ? rank[c] : 4;
    }
    function worstCat(cats){
      if (!cats.length) return "UNK";
      let best = "UNK";
      let r = 999;
      for (const c of cats){
        const cr = catRank(c);
        if (cr < r){ r = cr; best = c; }
      }
      return String(best || "UNK").toUpperCase();
    }
    function segClass(cat){
      switch (String(cat || "").toUpperCase()){
        case "VFR":  return "seg-vfr";
        case "MVFR": return "seg-mvfr";
        case "IFR":  return "seg-ifr";
        case "LIFR": return "seg-lifr";
        default:     return "seg-unk";
      }
    }

    function buildTafTimelineSegments(fcsts, startSec, endSec, stepSec){
      // sample timeline and collapse into contiguous segments
      const samples = [];
      for (let t = startSec; t < endSec; t += stepSec){
        const applicable = (fcsts || []).filter(f => Number.isFinite(f.timeFrom) && Number.isFinite(f.timeTo) && f.timeFrom <= t && t < f.timeTo);
        const cats = applicable.map(f => {
          const v = visToNumber(f.visib);
          const ceil = ceilingFeetFromClouds(f.clouds);
          return flightCategoryFrom(v, ceil);
        });
        samples.push({ t, cat: worstCat(cats) });
      }

      if (!samples.length) return [{ cat:"UNK", from:startSec, to:endSec }];

      const segs = [];
      let cur = { cat: samples[0].cat, from: startSec, to: Math.min(endSec, startSec + stepSec) };

      for (let i = 1; i < samples.length; i++){
        const nextFrom = startSec + i * stepSec;
        const nextTo = Math.min(endSec, nextFrom + stepSec);
        const c = samples[i].cat;

        if (c === cur.cat){
          cur.to = nextTo;
        } else {
          segs.push(cur);
          cur = { cat: c, from: nextFrom, to: nextTo };
        }
      }
      segs.push(cur);
      return segs;
    }

    function renderTafBar(fcsts, tafValidFrom, tafValidTo){
      const bar = $("tafBar");
      const label = $("tafBarLabel");
      bar.innerHTML = "";

      const nowSec = Math.floor(Date.now()/1000);
      const windowStart = nowSec;
      const windowEnd = nowSec + 24*3600;
      const stepSec = 15*60; // 15-minute resolution

      const segs = buildTafTimelineSegments(fcsts || [], windowStart, windowEnd, stepSec);

      // Label
      const startTxt = new Date(windowStart*1000).toLocaleTimeString([], { hour:"2-digit", minute:"2-digit" });
      const endTxt = new Date(windowEnd*1000).toLocaleTimeString([], { hour:"2-digit", minute:"2-digit" });
      label.textContent = `Next 24h: ${startTxt} → ${endTxt}`;

      // Render segments with proportional widths
      const total = (windowEnd - windowStart);
      for (const s of segs){
        const dur = Math.max(0, s.to - s.from);
        if (dur <= 0) continue;

        const div = document.createElement("div");
        div.className = `tafSeg ${segClass(s.cat)}`;
        div.style.flex = String(dur); // proportional
        const a = new Date(s.from*1000).toLocaleTimeString([], { hour:"2-digit", minute:"2-digit" });
        const b = new Date(s.to*1000).toLocaleTimeString([], { hour:"2-digit", minute:"2-digit" });
        div.title = `${s.cat}  ${a}–${b}`;
        bar.appendChild(div);
      }
    }

    // ====== LOADERS ======
    async function loadMetar(){
      const metarraw = $("metarraw");

      try{
        const arr = await fetchJSON(`/metar?ids=${encodeURIComponent(STATION)}`);
        const m = (Array.isArray(arr) && arr.length) ? arr[0] : null;
        if (!m) throw new Error("No METAR returned");

        const raw = safe(m.rawOb || m.raw || m.text, JSON.stringify(m, null, 2));
        const cat = String(m.fltCat || "UNK").toUpperCase();

        $("catText").textContent = cat;
        $("catText").className = catClass(cat);
        $("catDot").style.background = catColorVar(cat);

        const obs = m.obsTime || m.reportTime || m.time;
        lastObsMs = parseTimeToMs(obs);
        $("obstime").textContent = formatObsLineFromMs(lastObsMs);
        refreshAgeOnly();

        const hazards = detectMetarHazards(raw, m.visib);

        metarraw.className = "metarRaw mono " + catClass(cat);
        metarraw.innerHTML = formatMetarRawHTML(raw, hazards);

        setKv("m_time", formatLocalTimeWithTZFromMs(lastObsMs));

        const windTxt = (m.wdir != null && m.wspd != null)
          ? `${String(m.wdir).padStart(3,"0")}° at ${m.wspd}${m.wgst ? " - " + m.wgst : ""} kts`
          : "—";
        setKv("m_wind", windTxt);

        let visTxt = "—";
        if (m.visib != null){
          const s = String(m.visib);
          if (/^6\+/.test(s) || s === "6+") visTxt = "10+ sm";
          else visTxt = `${s} sm`;
        } else if (hazards.visToken){
          visTxt = hazards.visToken.replace(/\s+/g, " ");
        }
        setKv("m_vis", visTxt, hazards.visLow);

        setKv("m_clouds", cloudPhrase(m.clouds));

        const tC = Number.isFinite(m.temp) ? m.temp : null;
        const dC = Number.isFinite(m.dewp) ? m.dewp : null;
        const tF = (tC == null) ? null : cToF(tC);
        const dF = (dC == null) ? null : cToF(dC);

        setKv("m_temp", (tC == null || tF == null) ? "—" : `${tC.toFixed(1)}°C (${Math.round(tF)}°F)`);
        setKv("m_dew",  (dC == null || dF == null) ? "—" : `${dC.toFixed(1)}°C (${Math.round(dF)}°F)`);

        const altInHg = parseAltimeterInHg(m.altim);
        setKv("m_alt", (altInHg == null) ? "—" : `${altInHg.toFixed(2)} inHg`);

      } catch(e){
        $("catText").textContent = "—";
        $("catText").className = "cat-unk";
        $("catDot").style.background = "var(--unk)";
        $("ageBadge").textContent = "—";

        metarraw.textContent = `ERROR loading METAR: ${e.message}`;
        metarraw.className = "metarRaw mono error";

        lastObsMs = null;
        $("obstime").textContent = "—";
      }
    }

    async function loadTaf(){
      const tafmeta = $("tafmeta");
      const tafBlock = $("tafBlock");
      tafBlock.className = "tafBlock mono cat-unk";
      tafBlock.textContent = "";
      tafBlock.innerHTML = "";

      try{
        const arr = await fetchJSON(`/taf?ids=${encodeURIComponent(STATION)}`);
        const t = (Array.isArray(arr) && arr.length) ? arr[0] : null;
        if (!t) throw new Error("No TAF returned");

        tafmeta.textContent =
          `Issued: ${safe(t.issueTime)} • Valid: ${fmtUnixLocal(t.validTimeFrom)}–${fmtUnixLocal(t.validTimeTo)}`;

        const raw = t.rawTAF || t.rawOb || t.raw || t.text || "";
        const lines = tafRawToLines(raw);
        const fcsts = Array.isArray(t.fcsts) ? t.fcsts : [];

        if (!lines.length){
          tafBlock.textContent = "No TAF text returned.";
        } else {
          lines.forEach((line, i) => {
            const f = fcsts[i] || null;
            const visN = f ? visToNumber(f.visib) : null;
            const ceil = f ? ceilingFeetFromClouds(f.clouds) : null;
            const cat = f ? flightCategoryFrom(visN, ceil) : "UNK";

            const span = document.createElement("span");
            span.className = `tafLine ${catClass(cat)}`;
            span.textContent = line;

            tafBlock.appendChild(span);
            tafBlock.appendChild(document.createTextNode("\n"));
          });
        }

        // NEW: render 24h category bar from fcsts
        renderTafBar(fcsts, t.validTimeFrom, t.validTimeTo);

      } catch(e){
        tafmeta.textContent = "";
        tafBlock.textContent = `ERROR loading TAF: ${e.message}`;
        tafBlock.className = "tafBlock mono error";
        $("tafBarLabel").textContent = "Next 24h: —";
        $("tafBar").innerHTML = "";
      }
    }

    function init(){
      setClock();
      $("windyRadar").src = WINDY_RADAR_URL;

      loadMetar();
      loadTaf();

      setInterval(setClock, 10_000);
      setInterval(refreshAgeOnly, 30_000);

      setInterval(loadMetar, 60_000);
      setInterval(loadTaf,  5 * 60_000);

      // keep the bar label current even between TAF refreshes
      setInterval(() => {
        // Re-render bar using latest already-rendered segments isn’t stored,
        // so just update label if it exists; full re-render happens on TAF refresh.
        const now = new Date();
        $("clock").textContent = now.toLocaleString();
      }, 30_000);
    }

    init();
  </script>
</body>
</html>
