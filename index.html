<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KFOE Field Conditions & Weather</title>

  <style>
    :root{
      --bg:#0b0f14;
      --card:#111823;
      --text:#e8eef6;
      --muted:#9fb0c3;
      --accent:#57a6ff;

      --vfr:#2bdc4f;
      --mvfr:#4aa3ff;
      --ifr:#ff4d4d;     /* RED */
      --lifr:#c84dff;    /* MAGENTA */
      --unk:#6f7d8f;

      --age:#ff9a3d;
      --divider:rgba(255,255,255,0.08);
    }

    *{ box-sizing:border-box; }
    html, body{ height:100%; overflow:hidden; }
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background:var(--bg);
      color:var(--text);
    }

    .wrap{
      height:100vh;
      display:grid;
      grid-template-rows:auto 1fr;
      gap:12px;
      padding:16px;
      min-height:0;
    }

    header{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:16px;
    }

    .title{
      font-size:clamp(22px, 1.8vw, 30px);
      font-weight:800;
      letter-spacing:0.2px;
    }
    .subtitle{
      color:var(--muted);
      font-size:clamp(12px, 0.9vw, 14px);
      margin-top:2px;
    }

    /* ===== Layout: left 1/3 (metar+taf), right 2/3 (windy) ===== */
    .main{
      height:100%;
      min-height:0;
      display:grid;
      grid-template-columns: 1fr 2fr; /* 1/3 : 2/3 */
      gap:12px;
    }

    .left{
      min-height:0;
      display:grid;
      grid-template-rows: 1.05fr 0.95fr;
      gap:12px;
    }

    .card{
      background:var(--card);
      border:1px solid rgba(255,255,255,0.06);
      border-radius:16px;
      padding:14px;
      overflow:hidden;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
      min-height:0;
      display:flex;
      flex-direction:column;
    }

    .card h2{
      margin:0 0 10px 0;
      font-size:clamp(14px, 1vw, 16px);
      color:var(--muted);
      font-weight:700;
      letter-spacing:0.3px;
      flex:0 0 auto;
    }

    iframe{
      width:100%;
      flex:1;
      min-height:0;
      border:0;
      border-radius:12px;
      background:#000;
    }

    .small{ color:var(--muted); font-size:12px; }
    .accent{ color:var(--accent); font-weight:800; }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }

    .cat-vfr{ color:var(--vfr); }
    .cat-mvfr{ color:var(--mvfr); }
    .cat-ifr{ color:var(--ifr); }
    .cat-lifr{ color:var(--lifr); }
    .cat-unk{ color:#d7e3f3; }
    .error{ color:#ff6b6b; font-weight:900; }

    /* hazard highlight (RED) */
    .haz-red{
      color: var(--ifr);
      font-weight: 1000;
    }

    /* ===== METAR ===== */
    .metarTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:10px 12px;
      border-radius:14px;
      background:rgba(255,255,255,0.03);
      border:1px solid rgba(255,255,255,0.06);
      margin-bottom:10px;
      flex:0 0 auto;
    }
    .catBadge{
      display:flex;
      align-items:center;
      gap:10px;
      font-weight:900;
      font-size:clamp(18px, 1.55vw, 24px);
      letter-spacing:0.4px;
    }
    .dot{
      width:22px;
      height:22px;
      border-radius:999px;
      box-shadow: 0 0 0 3px rgba(255,255,255,0.06) inset;
    }
    .ageBadge{
      font-weight:900;
      font-size:clamp(16px, 1.35vw, 22px);
      color:var(--age);
      white-space:nowrap;
    }

    .metarRaw{
      font-size:clamp(12px, 0.95vw, 15px);
      font-weight:900;
      padding:10px 12px;
      border-radius:14px;
      background:rgba(255,255,255,0.02);
      border:1px solid rgba(255,255,255,0.06);
      margin-bottom:10px;
      line-height:1.25;
      white-space:pre-wrap;
      word-break:break-word;
      flex:0 0 auto;
    }

    .kvTable{
      border-radius:16px;
      background:rgba(255,255,255,0.02);
      border:1px solid rgba(255,255,255,0.06);
      overflow:hidden;
      flex:1 1 auto;
      min-height:0;
      display:flex;
      flex-direction:column;
    }

    .kvRow{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      padding:clamp(6px, 0.7vh, 10px) 12px;
      border-top:1px solid var(--divider);
      align-items:center;
      flex: 1 0 auto;
      min-height:0;
    }
    .kvRow:first-child{ border-top:none; }

    .kvLabel{
      color:rgba(255,255,255,0.92);
      font-size:clamp(12px, 0.9vw, 15px);
      font-weight:800;
      text-align:center;
      line-height:1.1;
    }
    .kvValue{
      color:var(--mvfr);
      font-size:clamp(12px, 0.95vw, 16px);
      font-weight:900;
      text-align:center;
      letter-spacing:0.2px;
      line-height:1.1;
      white-space:nowrap;
    }

    .obsLine{
      margin-top:8px;
      flex:0 0 auto;
      font-size:12px;
      color:var(--muted);
    }

    /* ===== TAF ===== */
    .tafHeader{ flex:0 0 auto; }

    .tafBlock{
      flex:1 1 auto;
      min-height:0;
      white-space:pre-wrap;
      word-break:break-word;
      font-size:clamp(12px, 0.95vw, 14px);
      line-height:1.35;
      overflow:hidden;
      padding-top:2px;

      -webkit-mask-image: linear-gradient(to bottom, #000 90%, transparent);
      mask-image: linear-gradient(to bottom, #000 90%, transparent);
    }
    .tafLine{ display:block; padding:2px 0; }

    /* ===== TAF timeline bar (8 x 3-hour blocks) ===== */
    .tafBarWrap{
      flex:0 0 auto;
      margin-top:10px;
    }
    .tafBarLabel{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      font-size:12px;
      color:var(--muted);
      margin-bottom:6px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .tafBar{
      position:relative;
      height:14px;
      border-radius:10px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,0.10);
      background:rgba(255,255,255,0.04);
      display:flex;
      gap:6px;
      padding:2px;
    }
    .tafSeg{
      height:100%;
      border-radius:8px;
      min-width:0;
      flex: 1 1 0;
      opacity:0.95;
    }
    .seg-vfr{ background:var(--vfr); }
    .seg-mvfr{ background:var(--mvfr); }
    .seg-ifr{ background:var(--ifr); }
    .seg-lifr{ background:var(--lifr); }
    .seg-unk{ background:var(--unk); }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div>
        <div class="title">KFOE — Forbes Field</div>
        <div class="subtitle">METAR/TAF + Radar (Windy) • Auto-refresh</div>
      </div>
      <div class="subtitle" id="clock"></div>
    </header>

    <div class="main">
      <!-- LEFT 1/3: METAR + TAF -->
      <div class="left">
        <!-- METAR -->
        <div class="card">
          <h2>METAR</h2>

          <div class="metarTop">
            <div class="catBadge">
              <span id="catDot" class="dot" style="background: var(--unk);"></span>
              <span id="catText" class="cat-unk">—</span>
            </div>
            <div id="ageBadge" class="ageBadge">—</div>
          </div>

          <div id="metarraw" class="metarRaw mono cat-unk">Loading…</div>

          <div class="kvTable">
            <div class="kvRow">
              <div class="kvLabel">Time</div>
              <div class="kvValue" id="m_time">—</div>
            </div>
            <div class="kvRow">
              <div class="kvLabel">Wind</div>
              <div class="kvValue" id="m_wind">—</div>
            </div>
            <div class="kvRow">
              <div class="kvLabel">Visibility</div>
              <div class="kvValue" id="m_vis">—</div>
            </div>
            <div class="kvRow">
              <div class="kvLabel">Clouds (AGL)</div>
              <div class="kvValue" id="m_clouds">—</div>
            </div>
            <div class="kvRow">
              <div class="kvLabel">Temperature</div>
              <div class="kvValue" id="m_temp">—</div>
            </div>
            <div class="kvRow">
              <div class="kvLabel">Dewpoint</div>
              <div class="kvValue" id="m_dew">—</div>
            </div>
            <div class="kvRow">
              <div class="kvLabel">Altimeter</div>
              <div class="kvValue" id="m_alt">—</div>
            </div>
          </div>

          <div class="obsLine">Obs time: <span class="accent" id="obstime">—</span></div>
        </div>

        <!-- TAF -->
        <div class="card">
          <div class="tafHeader">
            <h2>TAF (Raw with Line Breaks + Colors)</h2>
            <div class="small" id="tafmeta">Loading…</div>
          </div>

          <div id="tafBlock" class="tafBlock mono cat-unk">Loading…</div>

          <div class="tafBarWrap">
            <div class="tafBarLabel" id="tafBarLabel">Next 24h:</div>
            <div class="tafBar" id="tafBar" aria-label="TAF 24 hour flight category bar"></div>
          </div>
        </div>
      </div>

      <!-- RIGHT 2/3: Windy -->
      <div class="card">
        <h2>Radar / Weather Map (Windy embed)</h2>
        <iframe id="windyRadar" title="Windy Radar"></iframe>
      </div>
    </div>
  </div>

<script>
"use strict";

/* ====== CONFIG ====== */
const STATION = "KFOE";
const PROXY_BASE = "https://kfoe-awc-proxy.oliversheley.workers.dev";

// Marker/detail point (KFOE)
const DETAIL_LAT = 38.95083;
const DETAIL_LON = -95.66361;

// Map center point (zoomed-out focus)
const CENTER_LAT = 39.10;
const CENTER_LON = -95.80;

// Zoom: smaller = more zoomed out (try 7–10)
const WINDY_ZOOM = 8;

/* ====== STATE ====== */
let lastObsMs = null;

/* ====== HELPERS ====== */
const $ = (id) => document.getElementById(id);

function setClock() {
  const el = $("clock");
  if (el) el.textContent = new Date().toLocaleString();
}

function escapeHTML(s){
  return String(s ?? "")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#39;");
}

function parseTimeToMs(t){
  if (t == null) return null;
  if (typeof t === "number" && Number.isFinite(t)){
    if (t > 1e12) return t;
    if (t > 1e9)  return t * 1000;
    return null;
  }
  if (typeof t === "string"){
    const s = t.trim();
    if (/^\d{9,16}$/.test(s)){
      const n = Number(s);
      if (!Number.isFinite(n)) return null;
      if (n > 1e12) return n;
      if (n > 1e9)  return n * 1000;
    }
    const ms = Date.parse(s);
    return Number.isFinite(ms) ? ms : null;
  }
  return null;
}

function computeAgeMinutesFromMs(ms){
  if (!Number.isFinite(ms)) return null;
  const diff = Date.now() - ms;
  if (!Number.isFinite(diff) || diff < 0) return null;
  const mins = Math.round(diff / 60000);
  if (mins > 24 * 60 * 7) return null;
  return mins;
}

function refreshAgeOnly(){
  const mins = computeAgeMinutesFromMs(lastObsMs);
  const el = $("ageBadge");
  if (el) el.textContent = (mins == null) ? "—" : `${mins}m ago`;
}

function formatLocalTimeWithTZFromMs(ms){
  if (!Number.isFinite(ms)) return "—";
  return new Date(ms).toLocaleTimeString([], { hour:"2-digit", minute:"2-digit", timeZoneName:"short" });
}

function formatObsLineFromMs(ms){
  if (!Number.isFinite(ms)) return "—";
  return new Date(ms).toLocaleString([], { month:"2-digit", day:"2-digit", hour:"2-digit", minute:"2-digit", timeZoneName:"short" });
}

function formatMaybeISOorEpoch(x){
  const ms = parseTimeToMs(x);
  if (ms == null) return String(x ?? "—");
  return new Date(ms).toLocaleString([], { month:"2-digit", day:"2-digit", hour:"2-digit", minute:"2-digit", timeZoneName:"short" });
}

function safe(v, fallback="—"){
  return (v === undefined || v === null || v === "") ? fallback : v;
}

function catClass(cat){
  switch (String(cat || "").toUpperCase()){
    case "VFR":  return "cat-vfr";
    case "MVFR": return "cat-mvfr";
    case "IFR":  return "cat-ifr";
    case "LIFR": return "cat-lifr";
    default:     return "cat-unk";
  }
}
function catColorVar(cat){
  switch (String(cat || "").toUpperCase()){
    case "VFR":  return "var(--vfr)";
    case "MVFR": return "var(--mvfr)";
    case "IFR":  return "var(--ifr)";
    case "LIFR": return "var(--lifr)";
    default:     return "var(--unk)";
  }
}

async function fetchJSON(path){
  const url = `${PROXY_BASE}${path}`;
  const res = await fetch(url, { cache:"no-store" });
  if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
  return res.json();
}

/* ====== Windy URL ====== */
function buildWindyUrl(){
  return "https://embed.windy.com/embed2.html" +
    `?lat=${encodeURIComponent(CENTER_LAT)}` +
    `&lon=${encodeURIComponent(CENTER_LON)}` +
    `&detailLat=${encodeURIComponent(DETAIL_LAT)}` +
    `&detailLon=${encodeURIComponent(DETAIL_LON)}` +
    "&width=100%&height=100%" +
    `&zoom=${encodeURIComponent(WINDY_ZOOM)}` +
    "&level=surface" +
    "&overlay=rain" +
    "&product=ecmwf" +
    "&menu=&message=true&marker=true" +
    "&calendar=now&pressure=true" +
    "&type=map&location=coordinates&detail=true" +
    "&metricWind=default&metricTemp=default&radarRange=-1";
}

/* ====== Flight category compute from vis/ceiling ====== */
function parseVisSm(v){
  if (v == null) return null;
  if (typeof v === "number" && Number.isFinite(v)) return v;
  const s = String(v).trim();
  if (!s) return null;
  if (s === "6+" || s.startsWith("6+")) return 10;
  const n = parseFloat(s);
  return Number.isFinite(n) ? n : null;
}

function calcCeilingFt(clouds){
  if (!Array.isArray(clouds) || !clouds.length) return null;
  const candidates = clouds
    .map(c => ({
      cover: String(c.cover||"").toUpperCase(),
      base: Number.isFinite(c.base) ? c.base : null
    }))
    .filter(c => c.base != null && ["BKN","OVC","VV"].includes(c.cover))
    .sort((a,b)=>a.base-b.base);
  return candidates.length ? candidates[0].base : null;
}

function catFromCeilVis(ceilFt, visSm){
  // If both missing → UNK
  if (ceilFt == null && visSm == null) return "UNK";

  const c = (ceilFt == null) ? Infinity : ceilFt;
  const v = (visSm == null) ? Infinity : visSm;

  // Standard thresholds
  if (c < 500 || v < 1) return "LIFR";
  if (c < 1000 || v < 3) return "IFR";
  if (c < 3000 || v <= 5) return "MVFR";
  return "VFR";
}

/* ===== METAR helpers ===== */
function cloudPhrase(clouds){
  if (!Array.isArray(clouds) || !clouds.length) return "Clear";
  const sorted = clouds.filter(c=>Number.isFinite(c.base)).sort((a,b)=>a.base-b.base);
  if (!sorted.length) return "—";
  const pick = sorted.find(c => ["OVC","BKN","VV"].includes(String(c.cover||"").toUpperCase())) || sorted[0];
  const cover = String(pick.cover||"").toUpperCase();
  const base = pick.base;
  const coverWord = ({OVC:"Overcast",BKN:"Broken",SCT:"Scattered",FEW:"Few",VV:"Vertical Vis"})[cover] || cover;
  return `${coverWord} ${base.toLocaleString()}′`;
}

function cToF(c){ return Number.isFinite(c) ? (c * 9/5) + 32 : null; }

function parseAltimeterInHg(alt){
  if (alt == null) return null;
  const n = Number(alt);
  if (!Number.isFinite(n)) return null;
  if (n >= 20 && n <= 35) return n;
  if (n >= 2000 && n <= 3500) return n / 100;
  if (n >= 800 && n <= 1100) return n * 0.029529983;
  return null;
}

// Highlight: FZRA / FZDZ / FZFG and VIS <= 1/4SM patterns in the raw METAR
function highlightMetarRaw(raw, visSmMaybe){
  let html = escapeHTML(raw);

  // Freeze hazards
  html = html.replace(/\b(FZRA|FZDZ|FZFG)\b/g, `<span class="haz-red">$1</span>`);

  // Visibility 1/4SM or less common tokens
  html = html.replace(/\b(M?1\/4SM|1\/8SM|0SM|M1\/8SM|M1\/4SM)\b/g, `<span class="haz-red">$1</span>`);

  // If decoded vis <= 0.25, highlight ANY "SM" token occurrence as extra (optional, safe)
  if (Number.isFinite(visSmMaybe) && visSmMaybe <= 0.25){
    html = html.replace(/\b(\d+\s*)?SM\b/g, (m)=>`<span class="haz-red">${m}</span>`);
  }
  return html;
}

async function loadMetar(){
  const metarraw = $("metarraw");
  try{
    const arr = await fetchJSON(`/metar?ids=${encodeURIComponent(STATION)}`);
    const m = (Array.isArray(arr) && arr.length) ? arr[0] : null;
    if (!m) throw new Error("No METAR returned");

    const raw = safe(m.rawOb || m.raw || m.text, JSON.stringify(m, null, 2));
    const cat = String(m.fltCat || "UNK").toUpperCase();

    $("catText").textContent = cat;
    $("catText").className = catClass(cat);
    $("catDot").style.background = catColorVar(cat);

    const obs = m.obsTime || m.reportTime || m.time;
    lastObsMs = parseTimeToMs(obs);
    $("obstime").textContent = formatObsLineFromMs(lastObsMs);
    refreshAgeOnly();

    // decoded visibility for hazard highlight
    const visSm = parseVisSm(m.visib);

    metarraw.className = "metarRaw mono " + catClass(cat);
    metarraw.innerHTML = highlightMetarRaw(raw, visSm);

    $("m_time").textContent = formatLocalTimeWithTZFromMs(lastObsMs);

    const windTxt = (m.wdir != null && m.wspd != null)
      ? `${String(m.wdir).padStart(3,"0")}° at ${m.wspd}${m.wgst ? " - " + m.wgst : ""} kts`
      : "—";
    $("m_wind").textContent = windTxt;

    let visTxt = "—";
    if (m.visib != null){
      const s = String(m.visib);
      if (/^6\+/.test(s) || s === "6+") visTxt = "10+ sm";
      else visTxt = `${s} sm`;
    }
    $("m_vis").textContent = visTxt;

    // If vis <= 0.25 → make the VIS value red
    if (Number.isFinite(visSm) && visSm <= 0.25){
      $("m_vis").classList.add("haz-red");
    } else {
      $("m_vis").classList.remove("haz-red");
    }

    $("m_clouds").textContent = cloudPhrase(m.clouds);

    const tC = Number.isFinite(m.temp) ? m.temp : null;
    const dC = Number.isFinite(m.dewp) ? m.dewp : null;
    const tF = (tC == null) ? null : cToF(tC);
    const dF = (dC == null) ? null : cToF(dC);

    $("m_temp").textContent = (tC == null || tF == null) ? "—" : `${tC.toFixed(1)}°C (${Math.round(tF)}°F)`;
    $("m_dew").textContent  = (dC == null || dF == null) ? "—" : `${dC.toFixed(1)}°C (${Math.round(dF)}°F)`;

    const altInHg = parseAltimeterInHg(m.altim);
    $("m_alt").textContent = (altInHg == null) ? "—" : `${altInHg.toFixed(2)} inHg`;

  } catch(e){
    $("catText").textContent = "—";
    $("catText").className = "cat-unk";
    $("catDot").style.background = "var(--unk)";
    $("ageBadge").textContent = "—";
    $("obstime").textContent = "—";

    if (metarraw){
      metarraw.className = "metarRaw mono error";
      metarraw.textContent = `ERROR loading METAR: ${e.message}`;
    }
    lastObsMs = null;
  }
}

/* ===== TAF rendering with colored lines + 3h segments bar ===== */

function splitTafIntoLines(rawTAF){
  // Put newlines before FMxxxxxx, TEMPO ddhh/ddhh, BECMG ddhh/ddhh, PROBxx ddhh/ddhh
  // Keep it raw-ish (minimal formatting) like you requested.
  const s = String(rawTAF || "").trim();
  if (!s) return [];
  const withBreaks = s.replace(/\s+(FM\d{6}|TEMPO\s+\d{4}\/\d{4}|BECMG\s+\d{4}\/\d{4}|PROB\d{2}\s+\d{4}\/\d{4})/g, "\n$1");
  return withBreaks.split("\n").map(x=>x.trim()).filter(Boolean);
}

function buildFcstQueues(fcsts){
  const q = {
    BASE: [],
    FM: [],
    TEMPO: [],
    BECMG: [],
    PROB: [],
    OTHER: []
  };
  for (const f of (Array.isArray(fcsts) ? fcsts : [])){
    const ch = String(f.fcstChange || "").toUpperCase();
    if (!ch) q.BASE.push(f);
    else if (ch === "FM") q.FM.push(f);
    else if (ch === "TEMPO") q.TEMPO.push(f);
    else if (ch === "BECMG") q.BECMG.push(f);
    else if (ch.startsWith("PROB")) q.PROB.push(f);
    else q.OTHER.push(f);
  }
  return q;
}

function fcstCategory(fcst){
  if (!fcst) return "UNK";
  const ceil = calcCeilingFt(fcst.clouds);
  const vis  = parseVisSm(fcst.visib);
  return catFromCeilVis(ceil, vis);
}

function findFcstForTime(fcsts, tMs){
  // fcsts are epoch seconds; find one that covers tMs
  const tSec = Math.floor(tMs / 1000);
  for (const f of (Array.isArray(fcsts) ? fcsts : [])){
    const a = Number(f.timeFrom);
    const b = Number(f.timeTo);
    if (Number.isFinite(a) && Number.isFinite(b) && tSec >= a && tSec < b) return f;
  }
  return null;
}

function segClass(cat){
  switch (String(cat||"").toUpperCase()){
    case "VFR": return "seg-vfr";
    case "MVFR": return "seg-mvfr";
    case "IFR": return "seg-ifr";
    case "LIFR": return "seg-lifr";
    default: return "seg-unk";
  }
}

function prettyRangeLabel(startMs, endMs){
  const a = new Date(startMs).toLocaleTimeString([], { hour:"2-digit", minute:"2-digit" });
  const b = new Date(endMs).toLocaleTimeString([], { hour:"2-digit", minute:"2-digit" });
  return `${a}–${b}`;
}

async function loadTaf(){
  const tafmeta = $("tafmeta");
  const tafBlock = $("tafBlock");
  const tafBar = $("tafBar");
  const tafBarLabel = $("tafBarLabel");

  try{
    const arr = await fetchJSON(`/taf?ids=${encodeURIComponent(STATION)}`);
    const t = (Array.isArray(arr) && arr.length) ? arr[0] : null;
    if (!t) throw new Error("No TAF returned");

    const issue = t.issueTime || t.bulletinTime || t.dbPopTime;
    const validFrom = (Number.isFinite(Number(t.validTimeFrom)) ? Number(t.validTimeFrom) * 1000 : parseTimeToMs(t.validTimeFrom));
    const validTo   = (Number.isFinite(Number(t.validTimeTo))   ? Number(t.validTimeTo)   * 1000 : parseTimeToMs(t.validTimeTo));

    tafmeta.textContent =
      `Issued: ${formatMaybeISOorEpoch(issue)} • Valid: ${formatMaybeISOorEpoch(validFrom)}–${formatMaybeISOorEpoch(validTo)}`;

    const raw = String(t.rawTAF || t.rawOb || t.raw || t.text || "").trim();
    const lines = splitTafIntoLines(raw);

    // Color each line using fcsts (consume queues for FM/TEMPO/etc in order)
    const fcsts = Array.isArray(t.fcsts) ? t.fcsts : [];
    const q = buildFcstQueues(fcsts);

    const htmlLines = [];
    for (const line of lines){
      const upper = line.toUpperCase();
      let f = null;

      if (upper.startsWith("FM")) f = q.FM.shift() || null;
      else if (upper.startsWith("TEMPO")) f = q.TEMPO.shift() || null;
      else if (upper.startsWith("BECMG")) f = q.BECMG.shift() || null;
      else if (upper.startsWith("PROB")) f = q.PROB.shift() || null;
      else {
        // Header or initial group → use BASE if available, else first fcst
        f = q.BASE.shift() || fcsts[0] || null;
      }

      const cat = fcstCategory(f);
      htmlLines.push(`<span class="tafLine ${catClass(cat)}">${escapeHTML(line)}</span>`);
    }

    tafBlock.className = "tafBlock mono";
    tafBlock.innerHTML = htmlLines.join("");

    // Build 8 × 3-hour segments for Next 24h
    tafBarLabel.textContent = "Next 24h:";
    tafBar.innerHTML = "";

    const now = Date.now();
    let startMs = now;

    // Keep it within validity window if provided
    if (Number.isFinite(validFrom)) startMs = Math.max(startMs, validFrom);
    let endMs = startMs + 24 * 60 * 60 * 1000;
    if (Number.isFinite(validTo)) endMs = Math.min(endMs, validTo);

    // Always show 8 segments; if validity shorter, segments can show UNK
    const segHours = 3;
    const segMs = segHours * 60 * 60 * 1000;

    for (let i=0; i<8; i++){
      const a = startMs + i*segMs;
      const b = a + segMs;

      const f = findFcstForTime(fcsts, a);
      const cat = fcstCategory(f);

      const seg = document.createElement("div");
      seg.className = `tafSeg ${segClass(cat)}`;
      seg.title = `${prettyRangeLabel(a,b)} • ${cat}`;
      tafBar.appendChild(seg);
    }

  } catch(e){
    tafmeta.textContent = "";
    tafBlock.className = "tafBlock mono error";
    tafBlock.textContent = `ERROR loading TAF: ${e.message}`;
    tafBar.innerHTML = "";
    tafBarLabel.textContent = "Next 24h:";
  }
}

/* ====== INIT ====== */
function init(){
  try{
    setClock();

    const windy = $("windyRadar");
    if (windy) windy.src = buildWindyUrl();

    loadMetar();
    loadTaf();

    setInterval(setClock, 10_000);
    setInterval(refreshAgeOnly, 30_000);

    setInterval(loadMetar, 60_000);
    setInterval(loadTaf,  5 * 60_000);

  } catch (e){
    const metarraw = $("metarraw");
    if (metarraw){
      metarraw.className = "metarRaw mono error";
      metarraw.textContent = `JS ERROR: ${e.message}`;
    }
  }
}

window.addEventListener("DOMContentLoaded", init);
</script>
</body>
</html>
